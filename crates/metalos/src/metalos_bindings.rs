/* automatically generated by rust-bindgen 0.59.2 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const _STL_COMPILER_PREPROCESSOR: u32 = 1;
pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const NULL: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_NODISCARD: u32 = 1;
pub const _STL_WARNING_LEVEL: u32 = 3;
pub const _HAS_CONDITIONAL_EXPLICIT: u32 = 1;
pub const _STL_DISABLED_WARNING_C4984: u32 = 4984;
pub const _STL_DISABLED_WARNING_C5053: u32 = 5053;
pub const _CPPLIB_VER: u32 = 650;
pub const _MSVC_STL_VERSION: u32 = 143;
pub const _MSVC_STL_UPDATE: u32 = 202108;
pub const _HAS_STATIC_RTTI: u32 = 1;
pub const _HAS_STD_BYTE: u32 = 0;
pub const _ENFORCE_MATCHING_ALLOCATORS: u32 = 0;
pub const _ENFORCE_FACET_SPECIALIZATIONS: u32 = 0;
pub const _FACET_SPECIALIZATION_MESSAGE : & [u8 ; 183usize] = b"Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 to suppress this diagnostic.\0" ;
pub const _STL_OPTIMIZE_SYSTEM_ERROR_OPERATORS: u32 = 1;
pub const _STD_VECTORIZE_WITH_FLOAT_CONTROL: u32 = 1;
pub const __cpp_lib_chrono_udls: u32 = 201304;
pub const __cpp_lib_complex_udls: u32 = 201309;
pub const __cpp_lib_exchange_function: u32 = 201304;
pub const __cpp_lib_generic_associative_lookup: u32 = 201304;
pub const __cpp_lib_integer_sequence: u32 = 201304;
pub const __cpp_lib_integral_constant_callable: u32 = 201304;
pub const __cpp_lib_is_final: u32 = 201402;
pub const __cpp_lib_is_null_pointer: u32 = 201309;
pub const __cpp_lib_make_reverse_iterator: u32 = 201402;
pub const __cpp_lib_make_unique: u32 = 201304;
pub const __cpp_lib_null_iterators: u32 = 201304;
pub const __cpp_lib_quoted_string_io: u32 = 201304;
pub const __cpp_lib_result_of_sfinae: u32 = 201210;
pub const __cpp_lib_robust_nonmodifying_seq_ops: u32 = 201304;
pub const __cpp_lib_shared_timed_mutex: u32 = 201402;
pub const __cpp_lib_string_udls: u32 = 201304;
pub const __cpp_lib_transformation_trait_aliases: u32 = 201304;
pub const __cpp_lib_tuple_element_t: u32 = 201402;
pub const __cpp_lib_tuples_by_type: u32 = 201304;
pub const __cpp_lib_addressof_constexpr: u32 = 201603;
pub const __cpp_lib_allocator_traits_is_always_equal: u32 = 201411;
pub const __cpp_lib_as_const: u32 = 201510;
pub const __cpp_lib_bool_constant: u32 = 201505;
pub const __cpp_lib_enable_shared_from_this: u32 = 201603;
pub const __cpp_lib_incomplete_container_elements: u32 = 201505;
pub const __cpp_lib_invoke: u32 = 201411;
pub const __cpp_lib_logical_traits: u32 = 201510;
pub const __cpp_lib_map_try_emplace: u32 = 201411;
pub const __cpp_lib_nonmember_container_access: u32 = 201411;
pub const __cpp_lib_shared_mutex: u32 = 201505;
pub const __cpp_lib_transparent_operators: u32 = 201510;
pub const __cpp_lib_type_trait_variable_templates: u32 = 201510;
pub const __cpp_lib_uncaught_exceptions: u32 = 201411;
pub const __cpp_lib_unordered_map_try_emplace: u32 = 201411;
pub const __cpp_lib_void_t: u32 = 201411;
pub const __cpp_lib_atomic_value_initialization: u32 = 201911;
pub const __cpp_lib_chrono: u32 = 201510;
pub const __cpp_lib_shared_ptr_arrays: u32 = 201611;
pub const __cpp_lib_experimental_erase_if: u32 = 201411;
pub const __cpp_lib_experimental_filesystem: u32 = 201406;
pub const _STL_WIN32_WINNT_WINXP: u32 = 1281;
pub const _STL_WIN32_WINNT_VISTA: u32 = 1536;
pub const _STL_WIN32_WINNT_WIN8: u32 = 1538;
pub const _STL_WIN32_WINNT_WINBLUE: u32 = 1539;
pub const _STL_WIN32_WINNT_WIN10: u32 = 2560;
pub const _STL_WIN32_WINNT: u32 = 1536;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const _WIN32_WINNT: u32 = 2560;
pub const VK_UNMAPPED: u32 = 0;
pub const VK_LBUTTON: u32 = 1;
pub const VK_RBUTTON: u32 = 2;
pub const VK_CANCEL: u32 = 3;
pub const VK_MBUTTON: u32 = 4;
pub const VK_XBUTTON1: u32 = 5;
pub const VK_XBUTTON2: u32 = 6;
pub const VK_BACK: u32 = 8;
pub const VK_TAB: u32 = 9;
pub const VK_CLEAR: u32 = 12;
pub const VK_RETURN: u32 = 13;
pub const VK_SHIFT: u32 = 16;
pub const VK_CONTROL: u32 = 17;
pub const VK_MENU: u32 = 18;
pub const VK_PAUSE: u32 = 19;
pub const VK_CAPITAL: u32 = 20;
pub const VK_KANA: u32 = 21;
pub const VK_HANGEUL: u32 = 21;
pub const VK_HANGUL: u32 = 21;
pub const VK_JUNJA: u32 = 23;
pub const VK_FINAL: u32 = 24;
pub const VK_HANJA: u32 = 25;
pub const VK_KANJI: u32 = 25;
pub const VK_ESCAPE: u32 = 27;
pub const VK_CONVERT: u32 = 28;
pub const VK_NONCONVERT: u32 = 29;
pub const VK_ACCEPT: u32 = 30;
pub const VK_MODECHANGE: u32 = 31;
pub const VK_SPACE: u32 = 32;
pub const VK_PRIOR: u32 = 33;
pub const VK_NEXT: u32 = 34;
pub const VK_END: u32 = 35;
pub const VK_HOME: u32 = 36;
pub const VK_LEFT: u32 = 37;
pub const VK_UP: u32 = 38;
pub const VK_RIGHT: u32 = 39;
pub const VK_DOWN: u32 = 40;
pub const VK_SELECT: u32 = 41;
pub const VK_PRINT: u32 = 42;
pub const VK_EXECUTE: u32 = 43;
pub const VK_SNAPSHOT: u32 = 44;
pub const VK_INSERT: u32 = 45;
pub const VK_DELETE: u32 = 46;
pub const VK_HELP: u32 = 47;
pub const VK_LWIN: u32 = 91;
pub const VK_RWIN: u32 = 92;
pub const VK_APPS: u32 = 93;
pub const VK_SLEEP: u32 = 95;
pub const VK_NUMPAD0: u32 = 96;
pub const VK_NUMPAD1: u32 = 97;
pub const VK_NUMPAD2: u32 = 98;
pub const VK_NUMPAD3: u32 = 99;
pub const VK_NUMPAD4: u32 = 100;
pub const VK_NUMPAD5: u32 = 101;
pub const VK_NUMPAD6: u32 = 102;
pub const VK_NUMPAD7: u32 = 103;
pub const VK_NUMPAD8: u32 = 104;
pub const VK_NUMPAD9: u32 = 105;
pub const VK_MULTIPLY: u32 = 106;
pub const VK_ADD: u32 = 107;
pub const VK_SEPARATOR: u32 = 108;
pub const VK_SUBTRACT: u32 = 109;
pub const VK_DECIMAL: u32 = 110;
pub const VK_DIVIDE: u32 = 111;
pub const VK_F1: u32 = 112;
pub const VK_F2: u32 = 113;
pub const VK_F3: u32 = 114;
pub const VK_F4: u32 = 115;
pub const VK_F5: u32 = 116;
pub const VK_F6: u32 = 117;
pub const VK_F7: u32 = 118;
pub const VK_F8: u32 = 119;
pub const VK_F9: u32 = 120;
pub const VK_F10: u32 = 121;
pub const VK_F11: u32 = 122;
pub const VK_F12: u32 = 123;
pub const VK_F13: u32 = 124;
pub const VK_F14: u32 = 125;
pub const VK_F15: u32 = 126;
pub const VK_F16: u32 = 127;
pub const VK_F17: u32 = 128;
pub const VK_F18: u32 = 129;
pub const VK_F19: u32 = 130;
pub const VK_F20: u32 = 131;
pub const VK_F21: u32 = 132;
pub const VK_F22: u32 = 133;
pub const VK_F23: u32 = 134;
pub const VK_F24: u32 = 135;
pub const VK_NAVIGATION_VIEW: u32 = 136;
pub const VK_NAVIGATION_MENU: u32 = 137;
pub const VK_NAVIGATION_UP: u32 = 138;
pub const VK_NAVIGATION_DOWN: u32 = 139;
pub const VK_NAVIGATION_LEFT: u32 = 140;
pub const VK_NAVIGATION_RIGHT: u32 = 141;
pub const VK_NAVIGATION_ACCEPT: u32 = 142;
pub const VK_NAVIGATION_CANCEL: u32 = 143;
pub const VK_NUMLOCK: u32 = 144;
pub const VK_SCROLL: u32 = 145;
pub const VK_OEM_NEC_EQUAL: u32 = 146;
pub const VK_OEM_FJ_JISHO: u32 = 146;
pub const VK_OEM_FJ_MASSHOU: u32 = 147;
pub const VK_OEM_FJ_TOUROKU: u32 = 148;
pub const VK_OEM_FJ_LOYA: u32 = 149;
pub const VK_OEM_FJ_ROYA: u32 = 150;
pub const VK_LSHIFT: u32 = 160;
pub const VK_RSHIFT: u32 = 161;
pub const VK_LCONTROL: u32 = 162;
pub const VK_RCONTROL: u32 = 163;
pub const VK_LMENU: u32 = 164;
pub const VK_RMENU: u32 = 165;
pub const VK_BROWSER_BACK: u32 = 166;
pub const VK_BROWSER_FORWARD: u32 = 167;
pub const VK_BROWSER_REFRESH: u32 = 168;
pub const VK_BROWSER_STOP: u32 = 169;
pub const VK_BROWSER_SEARCH: u32 = 170;
pub const VK_BROWSER_FAVORITES: u32 = 171;
pub const VK_BROWSER_HOME: u32 = 172;
pub const VK_VOLUME_MUTE: u32 = 173;
pub const VK_VOLUME_DOWN: u32 = 174;
pub const VK_VOLUME_UP: u32 = 175;
pub const VK_MEDIA_NEXT_TRACK: u32 = 176;
pub const VK_MEDIA_PREV_TRACK: u32 = 177;
pub const VK_MEDIA_STOP: u32 = 178;
pub const VK_MEDIA_PLAY_PAUSE: u32 = 179;
pub const VK_LAUNCH_MAIL: u32 = 180;
pub const VK_LAUNCH_MEDIA_SELECT: u32 = 181;
pub const VK_LAUNCH_APP1: u32 = 182;
pub const VK_LAUNCH_APP2: u32 = 183;
pub const VK_OEM_1: u32 = 186;
pub const VK_OEM_PLUS: u32 = 187;
pub const VK_OEM_COMMA: u32 = 188;
pub const VK_OEM_MINUS: u32 = 189;
pub const VK_OEM_PERIOD: u32 = 190;
pub const VK_OEM_2: u32 = 191;
pub const VK_OEM_3: u32 = 192;
pub const VK_GAMEPAD_A: u32 = 195;
pub const VK_GAMEPAD_B: u32 = 196;
pub const VK_GAMEPAD_X: u32 = 197;
pub const VK_GAMEPAD_Y: u32 = 198;
pub const VK_GAMEPAD_RIGHT_SHOULDER: u32 = 199;
pub const VK_GAMEPAD_LEFT_SHOULDER: u32 = 200;
pub const VK_GAMEPAD_LEFT_TRIGGER: u32 = 201;
pub const VK_GAMEPAD_RIGHT_TRIGGER: u32 = 202;
pub const VK_GAMEPAD_DPAD_UP: u32 = 203;
pub const VK_GAMEPAD_DPAD_DOWN: u32 = 204;
pub const VK_GAMEPAD_DPAD_LEFT: u32 = 205;
pub const VK_GAMEPAD_DPAD_RIGHT: u32 = 206;
pub const VK_GAMEPAD_MENU: u32 = 207;
pub const VK_GAMEPAD_VIEW: u32 = 208;
pub const VK_GAMEPAD_LEFT_THUMBSTICK_BUTTON: u32 = 209;
pub const VK_GAMEPAD_RIGHT_THUMBSTICK_BUTTON: u32 = 210;
pub const VK_GAMEPAD_LEFT_THUMBSTICK_UP: u32 = 211;
pub const VK_GAMEPAD_LEFT_THUMBSTICK_DOWN: u32 = 212;
pub const VK_GAMEPAD_LEFT_THUMBSTICK_RIGHT: u32 = 213;
pub const VK_GAMEPAD_LEFT_THUMBSTICK_LEFT: u32 = 214;
pub const VK_GAMEPAD_RIGHT_THUMBSTICK_UP: u32 = 215;
pub const VK_GAMEPAD_RIGHT_THUMBSTICK_DOWN: u32 = 216;
pub const VK_GAMEPAD_RIGHT_THUMBSTICK_RIGHT: u32 = 217;
pub const VK_GAMEPAD_RIGHT_THUMBSTICK_LEFT: u32 = 218;
pub const VK_OEM_4: u32 = 219;
pub const VK_OEM_5: u32 = 220;
pub const VK_OEM_6: u32 = 221;
pub const VK_OEM_7: u32 = 222;
pub const VK_OEM_8: u32 = 223;
pub const VK_OEM_AX: u32 = 225;
pub const VK_OEM_102: u32 = 226;
pub const VK_ICO_HELP: u32 = 227;
pub const VK_ICO_00: u32 = 228;
pub const VK_ICO_CLEAR: u32 = 230;
pub const VK_PACKET: u32 = 231;
pub const VK_OEM_RESET: u32 = 233;
pub const VK_OEM_JUMP: u32 = 234;
pub const VK_OEM_PA1: u32 = 235;
pub const VK_OEM_PA2: u32 = 236;
pub const VK_OEM_PA3: u32 = 237;
pub const VK_OEM_WSCTRL: u32 = 238;
pub const VK_OEM_CUSEL: u32 = 239;
pub const VK_OEM_ATTN: u32 = 240;
pub const VK_OEM_FINISH: u32 = 241;
pub const VK_OEM_COPY: u32 = 242;
pub const VK_OEM_AUTO: u32 = 243;
pub const VK_OEM_ENLW: u32 = 244;
pub const VK_OEM_BACKTAB: u32 = 245;
pub const VK_ATTN: u32 = 246;
pub const VK_CRSEL: u32 = 247;
pub const VK_EXSEL: u32 = 248;
pub const VK_EREOF: u32 = 249;
pub const VK_PLAY: u32 = 250;
pub const VK_ZOOM: u32 = 251;
pub const VK_NONAME: u32 = 252;
pub const VK_PA1: u32 = 253;
pub const VK_OEM_CLEAR: u32 = 254;
pub const PAGE_SHIFT: u32 = 12;
pub const PAGE_SIZE: u32 = 4096;
pub type va_list = *mut c_types::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut va_list, ...);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __vcrt_va_list_is_reference {
    pub _address: u8,
}
pub const __vcrt_va_list_is_reference___the_value: bool = false;
pub type __vcrt_va_list_is_reference__bindgen_ty_1 = bool;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __vcrt_assert_va_start_is_not_reference {
    pub _address: u8,
}
pub type size_t = c_types::c_ulonglong;
pub type __vcrt_bool = bool;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize);
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type int_least8_t = c_types::c_schar;
pub type int_least16_t = c_types::c_short;
pub type int_least32_t = c_types::c_int;
pub type int_least64_t = c_types::c_longlong;
pub type uint_least8_t = c_types::c_uchar;
pub type uint_least16_t = c_types::c_ushort;
pub type uint_least32_t = c_types::c_uint;
pub type uint_least64_t = c_types::c_ulonglong;
pub type int_fast8_t = c_types::c_schar;
pub type int_fast16_t = c_types::c_int;
pub type int_fast32_t = c_types::c_int;
pub type int_fast64_t = c_types::c_longlong;
pub type uint_fast8_t = c_types::c_uchar;
pub type uint_fast16_t = c_types::c_uint;
pub type uint_fast32_t = c_types::c_uint;
pub type uint_fast64_t = c_types::c_ulonglong;
pub type intmax_t = c_types::c_longlong;
pub type uintmax_t = c_types::c_ulonglong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BGRRPixel {
    pub __bindgen_anon_1: BGRRPixel__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union BGRRPixel__bindgen_ty_1 {
    pub __bindgen_anon_1: BGRRPixel__bindgen_ty_1__bindgen_ty_1,
    pub AsUint32: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct BGRRPixel__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_BGRRPixel__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<BGRRPixel__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(BGRRPixel__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<BGRRPixel__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(BGRRPixel__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl BGRRPixel__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Blue(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_Blue(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn Green(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_Green(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn Red(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_Red(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Blue: u32,
        Green: u32,
        Red: u32,
        Reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let Blue: u32 = unsafe { ::core::mem::transmute(Blue) };
            Blue as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let Green: u32 = unsafe { ::core::mem::transmute(Green) };
            Green as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let Red: u32 = unsafe { ::core::mem::transmute(Red) };
            Red as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_BGRRPixel__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<BGRRPixel__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(BGRRPixel__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<BGRRPixel__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(BGRRPixel__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<BGRRPixel__bindgen_ty_1>())).AsUint32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BGRRPixel__bindgen_ty_1),
            "::",
            stringify!(AsUint32)
        )
    );
}
#[test]
fn bindgen_test_layout_BGRRPixel() {
    assert_eq!(
        ::core::mem::size_of::<BGRRPixel>(),
        4usize,
        concat!("Size of: ", stringify!(BGRRPixel))
    );
    assert_eq!(
        ::core::mem::align_of::<BGRRPixel>(),
        4usize,
        concat!("Alignment of ", stringify!(BGRRPixel))
    );
}
pub type Color = BGRRPixel;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Colors {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}?White@Colors@@2UBGRRPixel@@B"]
    pub static Colors_White: Color;
}
extern "C" {
    #[link_name = "\u{1}?Blue@Colors@@2UBGRRPixel@@B"]
    pub static Colors_Blue: Color;
}
extern "C" {
    #[link_name = "\u{1}?Green@Colors@@2UBGRRPixel@@B"]
    pub static Colors_Green: Color;
}
extern "C" {
    #[link_name = "\u{1}?Red@Colors@@2UBGRRPixel@@B"]
    pub static Colors_Red: Color;
}
extern "C" {
    #[link_name = "\u{1}?Black@Colors@@2UBGRRPixel@@B"]
    pub static Colors_Black: Color;
}
#[test]
fn bindgen_test_layout_Colors() {
    assert_eq!(
        ::core::mem::size_of::<Colors>(),
        1usize,
        concat!("Size of: ", stringify!(Colors))
    );
    assert_eq!(
        ::core::mem::align_of::<Colors>(),
        1usize,
        concat!("Alignment of ", stringify!(Colors))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Point2D {
    pub X: size_t,
    pub Y: size_t,
}
#[test]
fn bindgen_test_layout_Point2D() {
    assert_eq!(
        ::core::mem::size_of::<Point2D>(),
        16usize,
        concat!("Size of: ", stringify!(Point2D))
    );
    assert_eq!(
        ::core::mem::align_of::<Point2D>(),
        8usize,
        concat!("Alignment of ", stringify!(Point2D))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Point2D>())).X as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Point2D),
            "::",
            stringify!(X)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Point2D>())).Y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Point2D),
            "::",
            stringify!(Y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Rectangle {
    pub X: size_t,
    pub Y: size_t,
    pub Width: size_t,
    pub Height: size_t,
}
#[test]
fn bindgen_test_layout_Rectangle() {
    assert_eq!(
        ::core::mem::size_of::<Rectangle>(),
        32usize,
        concat!("Size of: ", stringify!(Rectangle))
    );
    assert_eq!(
        ::core::mem::align_of::<Rectangle>(),
        8usize,
        concat!("Alignment of ", stringify!(Rectangle))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Rectangle>())).X as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Rectangle),
            "::",
            stringify!(X)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Rectangle>())).Y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Rectangle),
            "::",
            stringify!(Y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Rectangle>())).Width as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Rectangle),
            "::",
            stringify!(Width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Rectangle>())).Height as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Rectangle),
            "::",
            stringify!(Height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReadOnlyBuffer {
    pub Data: *const c_types::c_void,
    pub Length: size_t,
}
#[test]
fn bindgen_test_layout_ReadOnlyBuffer() {
    assert_eq!(
        ::core::mem::size_of::<ReadOnlyBuffer>(),
        16usize,
        concat!("Size of: ", stringify!(ReadOnlyBuffer))
    );
    assert_eq!(
        ::core::mem::align_of::<ReadOnlyBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(ReadOnlyBuffer))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ReadOnlyBuffer>())).Data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ReadOnlyBuffer),
            "::",
            stringify!(Data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ReadOnlyBuffer>())).Length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ReadOnlyBuffer),
            "::",
            stringify!(Length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Buffer {
    pub Data: *mut c_types::c_void,
    pub Length: size_t,
}
#[test]
fn bindgen_test_layout_Buffer() {
    assert_eq!(
        ::core::mem::size_of::<Buffer>(),
        16usize,
        concat!("Size of: ", stringify!(Buffer))
    );
    assert_eq!(
        ::core::mem::align_of::<Buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(Buffer))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Buffer>())).Data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Buffer),
            "::",
            stringify!(Data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Buffer>())).Length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Buffer),
            "::",
            stringify!(Length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProcessInfo {
    pub Id: u32,
}
#[test]
fn bindgen_test_layout_ProcessInfo() {
    assert_eq!(
        ::core::mem::size_of::<ProcessInfo>(),
        4usize,
        concat!("Size of: ", stringify!(ProcessInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<ProcessInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(ProcessInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ProcessInfo>())).Id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ProcessInfo),
            "::",
            stringify!(Id)
        )
    );
}
pub const DayOfWeek_Sunday: DayOfWeek = 0;
pub const DayOfWeek_Monday: DayOfWeek = 1;
pub const DayOfWeek_Tuesday: DayOfWeek = 2;
pub const DayOfWeek_Wednesday: DayOfWeek = 3;
pub const DayOfWeek_Thursday: DayOfWeek = 4;
pub const DayOfWeek_Friday: DayOfWeek = 5;
pub const DayOfWeek_Saturday: DayOfWeek = 6;
pub type DayOfWeek = c_types::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SystemTime {
    pub Year: u16,
    pub Month: u16,
    pub DayOfTheWeek: DayOfWeek,
    pub Day: u16,
    pub Hour: u16,
    pub Minute: u16,
    pub Second: u16,
    pub Milliseconds: u16,
}
#[test]
fn bindgen_test_layout_SystemTime() {
    assert_eq!(
        ::core::mem::size_of::<SystemTime>(),
        20usize,
        concat!("Size of: ", stringify!(SystemTime))
    );
    assert_eq!(
        ::core::mem::align_of::<SystemTime>(),
        4usize,
        concat!("Alignment of ", stringify!(SystemTime))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SystemTime>())).Year as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SystemTime),
            "::",
            stringify!(Year)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SystemTime>())).Month as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(SystemTime),
            "::",
            stringify!(Month)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SystemTime>())).DayOfTheWeek as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SystemTime),
            "::",
            stringify!(DayOfTheWeek)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SystemTime>())).Day as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SystemTime),
            "::",
            stringify!(Day)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SystemTime>())).Hour as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(SystemTime),
            "::",
            stringify!(Hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SystemTime>())).Minute as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SystemTime),
            "::",
            stringify!(Minute)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SystemTime>())).Second as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SystemTime),
            "::",
            stringify!(Second)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SystemTime>())).Milliseconds as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SystemTime),
            "::",
            stringify!(Milliseconds)
        )
    );
}
pub const SystemArchitecture_Unknown: SystemArchitecture = 0;
pub const SystemArchitecture_x64: SystemArchitecture = 1;
pub type SystemArchitecture = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SystemInfo {
    pub PageSize: u32,
    pub Architecture: SystemArchitecture,
    pub NumberOfProcessors: u32,
    pub AllocationGranularity: u32,
    pub MinimumApplicationAddress: usize,
    pub MaximumApplicationAddress: usize,
}
#[test]
fn bindgen_test_layout_SystemInfo() {
    assert_eq!(
        ::core::mem::size_of::<SystemInfo>(),
        32usize,
        concat!("Size of: ", stringify!(SystemInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<SystemInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(SystemInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SystemInfo>())).PageSize as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SystemInfo),
            "::",
            stringify!(PageSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SystemInfo>())).Architecture as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SystemInfo),
            "::",
            stringify!(Architecture)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SystemInfo>())).NumberOfProcessors as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SystemInfo),
            "::",
            stringify!(NumberOfProcessors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SystemInfo>())).AllocationGranularity as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SystemInfo),
            "::",
            stringify!(AllocationGranularity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SystemInfo>())).MinimumApplicationAddress as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SystemInfo),
            "::",
            stringify!(MinimumApplicationAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SystemInfo>())).MaximumApplicationAddress as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SystemInfo),
            "::",
            stringify!(MaximumApplicationAddress)
        )
    );
}
pub const GenericAccess_Read: GenericAccess = 1;
pub const GenericAccess_Write: GenericAccess = 2;
pub const GenericAccess_ReadWrite: GenericAccess = 3;
pub type GenericAccess = c_types::c_int;
pub const StandardHandle_Input: StandardHandle = 0;
pub const StandardHandle_Output: StandardHandle = 1;
pub const StandardHandle_Error: StandardHandle = 2;
pub type StandardHandle = c_types::c_int;
pub type Handle = *mut c_types::c_void;
pub type HThread = *mut c_types::c_void;
pub type HProcess = *mut c_types::c_void;
pub type HSharedMemory = *mut c_types::c_void;
pub type HRingBuffer = *mut c_types::c_void;
pub type HWindow = *mut c_types::c_void;
pub type HFile = *mut c_types::c_void;
pub type HEvent = *mut c_types::c_void;
pub type ThreadStart =
    ::core::option::Option<unsafe extern "C" fn(parameter: *mut c_types::c_void) -> size_t>;
pub type VirtualKey = u16;
pub const MessageType_KeyEvent: MessageType = 0;
pub const MessageType_MouseEvent: MessageType = 1;
pub const MessageType_PaintEvent: MessageType = 2;
pub type MessageType = c_types::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MessageHeader {
    pub MessageType: MessageType,
}
#[test]
fn bindgen_test_layout_MessageHeader() {
    assert_eq!(
        ::core::mem::size_of::<MessageHeader>(),
        4usize,
        concat!("Size of: ", stringify!(MessageHeader))
    );
    assert_eq!(
        ::core::mem::align_of::<MessageHeader>(),
        4usize,
        concat!("Alignment of ", stringify!(MessageHeader))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MessageHeader>())).MessageType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MessageHeader),
            "::",
            stringify!(MessageType)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct KeyEvent {
    pub Key: VirtualKey,
    pub Flags: KeyEvent__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct KeyEvent__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u8,
}
#[test]
fn bindgen_test_layout_KeyEvent__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<KeyEvent__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(KeyEvent__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<KeyEvent__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(KeyEvent__bindgen_ty_1))
    );
}
impl KeyEvent__bindgen_ty_1 {
    #[inline]
    pub fn Pressed(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Pressed(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(Pressed: u16) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Pressed: u16 = unsafe { ::core::mem::transmute(Pressed) };
            Pressed as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_KeyEvent() {
    assert_eq!(
        ::core::mem::size_of::<KeyEvent>(),
        4usize,
        concat!("Size of: ", stringify!(KeyEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<KeyEvent>(),
        2usize,
        concat!("Alignment of ", stringify!(KeyEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<KeyEvent>())).Key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(KeyEvent),
            "::",
            stringify!(Key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<KeyEvent>())).Flags as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(KeyEvent),
            "::",
            stringify!(Flags)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct MouseButtonState {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_MouseButtonState() {
    assert_eq!(
        ::core::mem::size_of::<MouseButtonState>(),
        1usize,
        concat!("Size of: ", stringify!(MouseButtonState))
    );
    assert_eq!(
        ::core::mem::align_of::<MouseButtonState>(),
        1usize,
        concat!("Alignment of ", stringify!(MouseButtonState))
    );
}
impl MouseButtonState {
    #[inline]
    pub fn LeftPressed(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_LeftPressed(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RightPressed(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RightPressed(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        LeftPressed: u8,
        RightPressed: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let LeftPressed: u8 = unsafe { ::core::mem::transmute(LeftPressed) };
            LeftPressed as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let RightPressed: u8 = unsafe { ::core::mem::transmute(RightPressed) };
            RightPressed as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MouseEvent {
    pub Buttons: MouseButtonState,
    pub XPosition: u16,
    pub YPosition: u16,
}
#[test]
fn bindgen_test_layout_MouseEvent() {
    assert_eq!(
        ::core::mem::size_of::<MouseEvent>(),
        6usize,
        concat!("Size of: ", stringify!(MouseEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<MouseEvent>(),
        2usize,
        concat!("Alignment of ", stringify!(MouseEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MouseEvent>())).Buttons as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MouseEvent),
            "::",
            stringify!(Buttons)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MouseEvent>())).XPosition as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(MouseEvent),
            "::",
            stringify!(XPosition)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MouseEvent>())).YPosition as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MouseEvent),
            "::",
            stringify!(YPosition)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PaintEvent {
    pub Region: Rectangle,
}
#[test]
fn bindgen_test_layout_PaintEvent() {
    assert_eq!(
        ::core::mem::size_of::<PaintEvent>(),
        32usize,
        concat!("Size of: ", stringify!(PaintEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<PaintEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(PaintEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PaintEvent>())).Region as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PaintEvent),
            "::",
            stringify!(Region)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Message {
    pub Header: MessageHeader,
    pub __bindgen_anon_1: Message__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Message__bindgen_ty_1 {
    pub KeyEvent: KeyEvent,
    pub MouseEvent: MouseEvent,
    pub PaintEvent: PaintEvent,
}
#[test]
fn bindgen_test_layout_Message__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<Message__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(Message__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<Message__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(Message__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Message__bindgen_ty_1>())).KeyEvent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Message__bindgen_ty_1),
            "::",
            stringify!(KeyEvent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<Message__bindgen_ty_1>())).MouseEvent as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Message__bindgen_ty_1),
            "::",
            stringify!(MouseEvent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<Message__bindgen_ty_1>())).PaintEvent as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Message__bindgen_ty_1),
            "::",
            stringify!(PaintEvent)
        )
    );
}
#[test]
fn bindgen_test_layout_Message() {
    assert_eq!(
        ::core::mem::size_of::<Message>(),
        40usize,
        concat!("Size of: ", stringify!(Message))
    );
    assert_eq!(
        ::core::mem::align_of::<Message>(),
        8usize,
        concat!("Alignment of ", stringify!(Message))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Message>())).Header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Message),
            "::",
            stringify!(Header)
        )
    );
}
pub const WaitStatus_None: WaitStatus = 0;
pub const WaitStatus_Signaled: WaitStatus = 1;
pub const WaitStatus_Timeout: WaitStatus = 2;
pub const WaitStatus_Abandoned: WaitStatus = 3;
pub const WaitStatus_BrokenPipe: WaitStatus = 4;
pub type WaitStatus = c_types::c_int;
pub const MemoryAllocationType_Commit: MemoryAllocationType = 1;
pub const MemoryAllocationType_Reserve: MemoryAllocationType = 2;
pub const MemoryAllocationType_CommitReserve: MemoryAllocationType = 3;
pub type MemoryAllocationType = c_types::c_int;
pub const MemoryProtection_PageRead: MemoryProtection = 1;
pub const MemoryProtection_PageWrite: MemoryProtection = 2;
pub const MemoryProtection_PageExecute: MemoryProtection = 4;
pub const MemoryProtection_PageReadWrite: MemoryProtection = 3;
pub const MemoryProtection_PageReadExecute: MemoryProtection = 5;
pub const MemoryProtection_PageReadWriteExecute: MemoryProtection = 7;
pub type MemoryProtection = c_types::c_int;
pub const MaxModuleName: size_t = 16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Module {
    pub Address: *mut c_types::c_void,
    pub Name: [c_types::c_char; 16usize],
}
#[test]
fn bindgen_test_layout_Module() {
    assert_eq!(
        ::core::mem::size_of::<Module>(),
        24usize,
        concat!("Size of: ", stringify!(Module))
    );
    assert_eq!(
        ::core::mem::align_of::<Module>(),
        8usize,
        concat!("Alignment of ", stringify!(Module))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Module>())).Address as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Module),
            "::",
            stringify!(Address)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Module>())).Name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Module),
            "::",
            stringify!(Name)
        )
    );
}
pub const MaxLoadedModules: size_t = 8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProcessEnvironmentBlock {
    pub ProcessId: u32,
    pub BaseAddress: usize,
    pub LoadedModules: [Module; 8usize],
    pub ModuleIndex: size_t,
}
#[test]
fn bindgen_test_layout_ProcessEnvironmentBlock() {
    assert_eq!(
        ::core::mem::size_of::<ProcessEnvironmentBlock>(),
        216usize,
        concat!("Size of: ", stringify!(ProcessEnvironmentBlock))
    );
    assert_eq!(
        ::core::mem::align_of::<ProcessEnvironmentBlock>(),
        8usize,
        concat!("Alignment of ", stringify!(ProcessEnvironmentBlock))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ProcessEnvironmentBlock>())).ProcessId as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ProcessEnvironmentBlock),
            "::",
            stringify!(ProcessId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ProcessEnvironmentBlock>())).BaseAddress as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ProcessEnvironmentBlock),
            "::",
            stringify!(BaseAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ProcessEnvironmentBlock>())).LoadedModules as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ProcessEnvironmentBlock),
            "::",
            stringify!(LoadedModules)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ProcessEnvironmentBlock>())).ModuleIndex as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(ProcessEnvironmentBlock),
            "::",
            stringify!(ModuleIndex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ThreadEnvironmentBlock {
    pub SelfPointer: *mut ThreadEnvironmentBlock,
    pub PEB: *mut ProcessEnvironmentBlock,
    pub ThreadStart: ThreadStart,
    pub Handle: Handle,
    pub Arg: *mut c_types::c_void,
    pub ThreadId: u32,
    pub Error: u32,
}
#[test]
fn bindgen_test_layout_ThreadEnvironmentBlock() {
    assert_eq!(
        ::core::mem::size_of::<ThreadEnvironmentBlock>(),
        48usize,
        concat!("Size of: ", stringify!(ThreadEnvironmentBlock))
    );
    assert_eq!(
        ::core::mem::align_of::<ThreadEnvironmentBlock>(),
        8usize,
        concat!("Alignment of ", stringify!(ThreadEnvironmentBlock))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ThreadEnvironmentBlock>())).SelfPointer as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadEnvironmentBlock),
            "::",
            stringify!(SelfPointer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadEnvironmentBlock>())).PEB as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadEnvironmentBlock),
            "::",
            stringify!(PEB)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ThreadEnvironmentBlock>())).ThreadStart as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadEnvironmentBlock),
            "::",
            stringify!(ThreadStart)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadEnvironmentBlock>())).Handle as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadEnvironmentBlock),
            "::",
            stringify!(Handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadEnvironmentBlock>())).Arg as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadEnvironmentBlock),
            "::",
            stringify!(Arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ThreadEnvironmentBlock>())).ThreadId as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadEnvironmentBlock),
            "::",
            stringify!(ThreadId)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadEnvironmentBlock>())).Error as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadEnvironmentBlock),
            "::",
            stringify!(Error)
        )
    );
}
pub const FilePointerMove_Begin: FilePointerMove = 0;
pub const FilePointerMove_Current: FilePointerMove = 1;
pub const FilePointerMove_End: FilePointerMove = 2;
pub type FilePointerMove = c_types::c_int;
pub const SystemCallResult_Success: SystemCallResult = 0;
pub const SystemCallResult_InvalidPointer: SystemCallResult = 1;
pub const SystemCallResult_InvalidHandle: SystemCallResult = 2;
pub const SystemCallResult_InvalidObject: SystemCallResult = 3;
pub const SystemCallResult_BrokenPipe: SystemCallResult = 4;
pub const SystemCallResult_Failed: SystemCallResult = 5;
pub const SystemCallResult_NotImplemented: SystemCallResult = 6;
pub type SystemCallResult = c_types::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateProcessArgs {
    pub StdInput: HFile,
    pub StdOutput: HFile,
    pub StdError: HFile,
}
#[test]
fn bindgen_test_layout_CreateProcessArgs() {
    assert_eq!(
        ::core::mem::size_of::<CreateProcessArgs>(),
        24usize,
        concat!("Size of: ", stringify!(CreateProcessArgs))
    );
    assert_eq!(
        ::core::mem::align_of::<CreateProcessArgs>(),
        8usize,
        concat!("Alignment of ", stringify!(CreateProcessArgs))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CreateProcessArgs>())).StdInput as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateProcessArgs),
            "::",
            stringify!(StdInput)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CreateProcessArgs>())).StdOutput as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateProcessArgs),
            "::",
            stringify!(StdOutput)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CreateProcessArgs>())).StdError as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateProcessArgs),
            "::",
            stringify!(StdError)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateProcessResult {
    pub Process: HProcess,
}
#[test]
fn bindgen_test_layout_CreateProcessResult() {
    assert_eq!(
        ::core::mem::size_of::<CreateProcessResult>(),
        8usize,
        concat!("Size of: ", stringify!(CreateProcessResult))
    );
    assert_eq!(
        ::core::mem::align_of::<CreateProcessResult>(),
        8usize,
        concat!("Alignment of ", stringify!(CreateProcessResult))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CreateProcessResult>())).Process as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateProcessResult),
            "::",
            stringify!(Process)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PipeInfo {
    pub BytesAvailable: size_t,
    pub IsBroken: bool,
}
#[test]
fn bindgen_test_layout_PipeInfo() {
    assert_eq!(
        ::core::mem::size_of::<PipeInfo>(),
        16usize,
        concat!("Size of: ", stringify!(PipeInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<PipeInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(PipeInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PipeInfo>())).BytesAvailable as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PipeInfo),
            "::",
            stringify!(BytesAvailable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PipeInfo>())).IsBroken as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PipeInfo),
            "::",
            stringify!(IsBroken)
        )
    );
}
extern "C" {
    pub fn GetSystemInfo(info: *mut SystemInfo) -> SystemCallResult;
}
extern "C" {
    pub fn GetTickCount() -> size_t;
}
extern "C" {
    pub fn GetSystemTime(time: *mut SystemTime) -> SystemCallResult;
}
extern "C" {
    pub fn GetProcessInfo(info: *mut ProcessInfo) -> SystemCallResult;
}
extern "C" {
    pub fn CreateProcess(
        processName: *const c_types::c_char,
        args: *const CreateProcessArgs,
        result: *mut CreateProcessResult,
    ) -> SystemCallResult;
}
extern "C" {
    pub fn GetThreadId(thread: HThread) -> u32;
}
extern "C" {
    pub fn GetCurrentThread() -> HThread;
}
extern "C" {
    pub fn GetCurrentThreadId() -> u64;
}
extern "C" {
    pub fn CreateThread(
        stackSize: size_t,
        startAddress: ThreadStart,
        arg: *mut c_types::c_void,
    ) -> HThread;
}
extern "C" {
    pub fn Sleep(milliseconds: u32);
}
extern "C" {
    pub fn SwitchToThread();
}
extern "C" {
    pub fn ExitProcess(exitCode: u32) -> SystemCallResult;
}
extern "C" {
    pub fn ExitThread(exitCode: u32) -> SystemCallResult;
}
extern "C" {
    pub fn GetLastError() -> u32;
}
extern "C" {
    pub fn SetLastError(errorCode: u32);
}
extern "C" {
    pub fn AllocWindow(handle: *mut HWindow, frame: *const Rectangle) -> SystemCallResult;
}
extern "C" {
    pub fn PaintWindow(handle: HWindow, buffer: *const ReadOnlyBuffer) -> SystemCallResult;
}
extern "C" {
    pub fn MoveWindow(handle: HWindow, frame: *const Rectangle) -> SystemCallResult;
}
extern "C" {
    pub fn GetWindowRect(handle: HWindow, frame: *mut Rectangle) -> SystemCallResult;
}
extern "C" {
    pub fn GetMessage(message: *mut Message) -> SystemCallResult;
}
extern "C" {
    pub fn PeekMessage(message: *mut Message) -> SystemCallResult;
}
extern "C" {
    pub fn GetScreenRect(rect: *mut Rectangle) -> SystemCallResult;
}
extern "C" {
    pub fn CreateFile(path: *const c_types::c_char, access: GenericAccess) -> HFile;
}
extern "C" {
    pub fn CreatePipe(readHandle: *mut HFile, writeHandle: *mut HFile) -> SystemCallResult;
}
extern "C" {
    pub fn ReadFile(
        handle: HFile,
        buffer: *mut c_types::c_void,
        bufferSize: size_t,
        bytesRead: *mut size_t,
    ) -> SystemCallResult;
}
extern "C" {
    pub fn WriteFile(
        handle: HFile,
        buffer: *const c_types::c_void,
        bufferSize: size_t,
        bytesWritten: *mut size_t,
    ) -> SystemCallResult;
}
extern "C" {
    pub fn SetFilePointer(
        handle: HFile,
        position: size_t,
        moveType: FilePointerMove,
        newPosition: *mut size_t,
    ) -> SystemCallResult;
}
extern "C" {
    pub fn CloseFile(handle: HFile) -> SystemCallResult;
}
extern "C" {
    pub fn MoveFile(
        existingFileName: *const c_types::c_char,
        newFileName: *const c_types::c_char,
    ) -> SystemCallResult;
}
extern "C" {
    pub fn DeleteFile(fileName: *const c_types::c_char) -> SystemCallResult;
}
extern "C" {
    pub fn CreateDirectory(path: *const c_types::c_char) -> SystemCallResult;
}
extern "C" {
    pub fn WaitForSingleObject(
        handle: Handle,
        milliseconds: u32,
        status: *mut WaitStatus,
    ) -> SystemCallResult;
}
extern "C" {
    pub fn GetPipeInfo(handle: HFile, info: *mut PipeInfo) -> SystemCallResult;
}
extern "C" {
    pub fn CloseHandle(handle: Handle) -> SystemCallResult;
}
extern "C" {
    pub fn CreateEvent(event: *mut HEvent, manual: bool, initial: bool) -> SystemCallResult;
}
extern "C" {
    pub fn SetEvent(event: HEvent) -> SystemCallResult;
}
extern "C" {
    pub fn ResetEvent(event: HEvent) -> SystemCallResult;
}
extern "C" {
    pub fn VirtualAlloc(
        address: *const c_types::c_void,
        size: size_t,
        allocationType: MemoryAllocationType,
        protect: MemoryProtection,
    ) -> *mut c_types::c_void;
}
extern "C" {
    pub fn CreateRingBuffer(
        name: *const c_types::c_char,
        indexSize: size_t,
        ringSize: size_t,
    ) -> HRingBuffer;
}
extern "C" {
    pub fn CreateSharedMemory(name: *const c_types::c_char, size: size_t) -> HSharedMemory;
}
extern "C" {
    pub fn MapObject(address: *const c_types::c_void, handle: Handle) -> *mut c_types::c_void;
}
extern "C" {
    pub fn MapSharedObject(
        address: *const c_types::c_void,
        name: *const c_types::c_char,
    ) -> *mut c_types::c_void;
}
extern "C" {
    pub fn DebugPrint(s: *const c_types::c_char) -> SystemCallResult;
}
extern "C" {
    pub fn DebugPrintBytes(s: *const c_types::c_char, length: size_t) -> SystemCallResult;
}
extern "C" {
    pub fn LoadLibrary(lpLibFileName: *const c_types::c_char) -> Handle;
}
extern "C" {
    pub fn GetProcAddress(hModule: Handle, lpProcName: *const c_types::c_char) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Thread {
    pub m_thread: HThread,
}
#[test]
fn bindgen_test_layout_Thread() {
    assert_eq!(
        ::core::mem::size_of::<Thread>(),
        8usize,
        concat!("Size of: ", stringify!(Thread))
    );
    assert_eq!(
        ::core::mem::align_of::<Thread>(),
        8usize,
        concat!("Alignment of ", stringify!(Thread))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Thread>())).m_thread as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread),
            "::",
            stringify!(m_thread)
        )
    );
}
pub const DllEntryReason_ProcessAttach: DllEntryReason = 0;
pub const DllEntryReason_ProcessDetach: DllEntryReason = 1;
pub const DllEntryReason_ThreadAttach: DllEntryReason = 2;
pub const DllEntryReason_ThreadDetach: DllEntryReason = 3;
pub type DllEntryReason = c_types::c_int;
pub type DllMainCall = ::core::option::Option<
    unsafe extern "C" fn(hinstDLL: Handle, fdwReason: DllEntryReason) -> u32,
>;
pub const DllMainName: &[u8; 8usize] = b"DllMain\0";
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RingBufferHeader {
    pub Capacity: size_t,
    pub ReadIndex: size_t,
    pub WriteIndex: size_t,
    pub ReadWriteLock: Handle,
}
#[test]
fn bindgen_test_layout_RingBufferHeader() {
    assert_eq!(
        ::core::mem::size_of::<RingBufferHeader>(),
        32usize,
        concat!("Size of: ", stringify!(RingBufferHeader))
    );
    assert_eq!(
        ::core::mem::align_of::<RingBufferHeader>(),
        8usize,
        concat!("Alignment of ", stringify!(RingBufferHeader))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RingBufferHeader>())).Capacity as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RingBufferHeader),
            "::",
            stringify!(Capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RingBufferHeader>())).ReadIndex as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RingBufferHeader),
            "::",
            stringify!(ReadIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RingBufferHeader>())).WriteIndex as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RingBufferHeader),
            "::",
            stringify!(WriteIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RingBufferHeader>())).ReadWriteLock as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RingBufferHeader),
            "::",
            stringify!(ReadWriteLock)
        )
    );
}
pub const UIChannelSize: size_t = 8192;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Channel {
    pub Inbound: Channel__bindgen_ty_1,
    pub Outbound: Channel__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Channel__bindgen_ty_1 {
    pub Header: *mut RingBufferHeader,
    pub Buffer: *mut c_types::c_char,
}
#[test]
fn bindgen_test_layout_Channel__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<Channel__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(Channel__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<Channel__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(Channel__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Channel__bindgen_ty_1>())).Header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Channel__bindgen_ty_1),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Channel__bindgen_ty_1>())).Buffer as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Channel__bindgen_ty_1),
            "::",
            stringify!(Buffer)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Channel__bindgen_ty_2 {
    pub Header: *mut RingBufferHeader,
    pub Buffer: *mut c_types::c_char,
}
#[test]
fn bindgen_test_layout_Channel__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<Channel__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(Channel__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<Channel__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(Channel__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Channel__bindgen_ty_2>())).Header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Channel__bindgen_ty_2),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Channel__bindgen_ty_2>())).Buffer as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Channel__bindgen_ty_2),
            "::",
            stringify!(Buffer)
        )
    );
}
#[test]
fn bindgen_test_layout_Channel() {
    assert_eq!(
        ::core::mem::size_of::<Channel>(),
        32usize,
        concat!("Size of: ", stringify!(Channel))
    );
    assert_eq!(
        ::core::mem::align_of::<Channel>(),
        8usize,
        concat!("Alignment of ", stringify!(Channel))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Channel>())).Inbound as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Channel),
            "::",
            stringify!(Inbound)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Channel>())).Outbound as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Channel),
            "::",
            stringify!(Outbound)
        )
    );
}
